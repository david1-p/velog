<h2 id="서버">서버</h2>
<h2 id="1-서버와-클라이언트">1. 서버와 클라이언트</h2>
<ul>
<li><strong>서버 (Server)</strong> : 클라이언트에게 네트워크를 통해 정보나 서비스를 제공하는 컴퓨터 또는 프로그램입니다.</li>
<li><strong>클라이언트 (Client)</strong> : 서버에게 정보나 서비스를 요청하는 컴퓨터 또는 프로그램입니다.</li>
</ul>
<hr />
<h2 id="2-웹-애플리케이션-운영-서버의-종류">2. 웹 애플리케이션 운영 서버의 종류</h2>
<p><img alt="웹 서버" src="https://media.licdn.com/dms/image/v2/D4E12AQHKf_bBEQ4RuQ/article-cover_image-shrink_720_1280/article-cover_image-shrink_720_1280/0/1700559586204?e=1763596800&amp;v=beta&amp;t=DLp_r2cYlfFWaOzba1i_lhL5IYYrOkka8Liovjt_hpM" /></p>
<h3 id="1-웹-서버-web-server">1) 웹 서버 (Web Server)</h3>
<ul>
<li><strong>역할 :</strong> <strong>정적 콘텐츠</strong>(예: HTML, CSS, 이미지)를 보관하고 있다가, 클라이언트가 요청하면 그 콘텐츠를 전달합니다.</li>
<li><strong>과정 :</strong><blockquote>
<p>클라이언트가 보고 싶은 콘텐츠를 웹 서버에 <strong>요청</strong>
  &rarr; 웹 서버는 자신이 가진 <strong>정적 콘텐츠 중</strong>에서 클라이언트가 요청한 것이 있는지 검색
  &rarr; 해당 콘텐츠를 발견하면 클라이언트에게 <strong>전달</strong>
  &rarr; 클라이언트는 자신이 요청했던 콘텐츠를 웹 서버로부터 받아 봄
  &rarr; 웹 서버는 클라이언트가 요청했던 내용을 저장 <strong>(logging)</strong></p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="2-애플리케이션-서버-application-server-was">2) 애플리케이션 서버 (Application Server, WAS)</h3>
<ul>
<li><strong>역할 :</strong> <strong>동적 콘텐츠</strong>(비즈니스 로직 처리, DB 조회 등이 필요한 콘텐츠)를 생성하여 클라이언트에게 전달하는 서버입니다. (보통 <strong>WAS (Web Application Server)</strong>라고 부릅니다.)</li>
<li><strong>과정 :</strong><blockquote>
<p>클라이언트가 웹 서버에 <strong>동적 콘텐츠</strong>를 요청
  &rarr; 웹 서버는 요청을 <strong>애플리케이션 서버(WAS)에 전달</strong>
  &rarr; 애플리케이션 서버는 <strong>비즈니스 로직을 실행</strong>하여 동적 콘텐츠를 <strong>생성</strong>
  &rarr; (필요시 다음 단계의 DB 서버에 데이터를 요청)
  &rarr; 생성된 동적 콘텐츠를 웹 서버로 <strong>전달</strong>
  &rarr; 애플리케이션 서버는 처리 내용을 저장 <strong>(logging)</strong>
  &rarr; 웹 서버는 애플리케이션 서버에게 받은 동적 콘텐츠를 클라이언트에게 <strong>전달</strong>
  &rarr; 웹 서버도 클라이언트가 요청했던 내용을 저장 <strong>(logging)</strong>
  &rarr; 클라이언트는 처음 웹 서버에 요청했던 동적 콘텐츠를 받아 봄</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="3-db-서버-database-server">3) DB 서버 (Database Server)</h3>
<ul>
<li><strong>역할 :</strong> 애플리케이션의 데이터를 <strong>영구적으로 저장하고 관리</strong>하며, 애플리케이션 서버의 요청에 따라 데이터를 조회, 수정, 삭제(CRUD)합니다.</li>
<li><strong>과정 :</strong><blockquote>
<p>클라이언트가 웹 서버에 <strong>동적 콘텐츠</strong>를 요청
  &rarr; 웹 서버는 이 요청을 <strong>애플리케이션 서버에 전달</strong>
  &rarr; 애플리케이션 서버는 <strong>비즈니스 로직을 실행</strong>하던 중 데이터가 필요함을 인지
  &rarr; 애플리케이션 서버는 DB 서버에 데이터 <strong>쿼리(Query)를 요청</strong>
  &rarr; DB 서버는 요청받은 쿼리를 실행하여 <strong>결과(데이터)를 반환</strong> (처리 내용 logging)
  &rarr; 애플리케이션 서버는 <strong>DB에서 받은 데이터를 가공</strong>하여 동적 콘텐츠(예: HTML, JSON)를 <strong>생성</strong>
  &rarr; 생성된 콘텐츠를 웹 서버에 <strong>전달</strong> (처리 내용 logging)
  &rarr; 웹 서버는 전달받은 콘텐츠를 클라이언트에게 <strong>제공</strong> (처리 내용 logging)</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="4-리버스-프록시-서버-reverse-proxy-server">4) 리버스 프록시 서버 (Reverse Proxy Server)</h3>
<ul>
<li><strong>역할 :</strong> 클라이언트의 요청을 <strong>대신 받아</strong> 내부 서버(웹 서버 또는 애플리케이션 서버)로 <strong>전달하는</strong> 서버입니다. 클라이언트는 리버스 프록시를 실제 서버라고 인식하며, 이를 통해 <strong>로드 밸런싱(부하 분산)</strong>, SSL 암호화, 캐싱 등의 기능을 수행합니다.</li>
<li><strong>과정 (로드 밸런싱 예시) :</strong><blockquote>
<p>(애플리케이션 서버 B, C가 리버스 프록시 뒤에 있다고 가정)</p>
<p>클라이언트가 서버에 콘텐츠를 <strong>요청</strong> (이 요청은 <strong>리버스 프록시 서버</strong>가 받음)
  &rarr; 리버스 프록시 서버는 자신이 관리하는 <strong>여러 대의 내부 서버(B, C) 상태를 확인</strong>
  &rarr; (예: B가 바쁘면) <strong>가장 한가한 C 서버</strong>에게 클라이언트의 요청을 <strong>전달(forwarding)</strong>
  &rarr; C 서버는 요청을 처리 (필요시 DB 조회)한 후 <strong>응답을 리버스 프록시 서버에게</strong> 반환
  &rarr; 리버스 프록시 서버가 이 응답을 <strong>최종적으로 클라이언트에게</strong> 전달
  &rarr; 클라이언트는 요청한 콘텐츠를 받아볼 수 있음</p>
</blockquote>
</li>
<li><strong>예시 :</strong> 수강 신청이나 티켓 예매 사이트처럼 트래픽이 몰릴 때, 리버스 프록시(로드 밸런서)가 요청을 여러 서버로 나누어 보내 시스템 다운을 방지합니다.</li>
</ul>
<hr />
<h3 id="5-캐시-서버-cache-server">5) 캐시 서버 (Cache Server)</h3>
<ul>
<li><strong>역할 :</strong> 자주 요청되는 <strong>데이터나 콘텐츠를 미리 복사해 저장</strong>(캐싱)해두고, 다음 요청 시 DB나 애플리케이션 서버를 거치지 않고 <strong>더 빠르게 응답</strong>하기 위한 서버입니다.</li>
<li><strong>과정 :</strong><blockquote>
<p>클라이언트가 이전에 요청했던 콘텐츠를 <strong>다시 요청</strong>
  &rarr; 리버스 프록시 또는 웹 서버가 요청을 받음
  &rarr; DB나 애플리케이션 서버에 요청하기 <strong>전에 캐시 서버를 먼저 확인</strong>
  &rarr; <strong>(Cache Hit)</strong> 캐시 서버에 해당 콘텐츠가 <strong>저장되어 있으면</strong>
  &rarr; DB/애플리케이션 서버를 거치지 않고 <strong>즉시 캐시에서 콘텐츠를 꺼내</strong> 응답
  &rarr; <strong>(Cache Miss)</strong> 만약 <strong>캐시에 없으면</strong>
  &rarr; 기존 방식대로 애플리케이션 서버와 DB 서버를 거쳐 콘텐츠를 가져옴
  &rarr; <strong>이 콘텐츠를 캐시 서버에 저장</strong>하고 클라이언트에게 전달 (다음 요청을 대비)</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>** 참고) 리버스 프록시 vs. 포워드 프록시**</p>
<ul>
<li><strong>포워드 프록시 (Forward Proxy):</strong> <strong>클라이언트 쪽에</strong> 위치합니다. 클라이언트가 인터넷(예: google.com)에 접속할 때 대신 요청을 보내주는 서버입니다. (예: 회사 내부망에서 외부 인터넷에 접속할 때 보안이나 캐싱을 위해 사용)</li>
<li><strong>리버스 프록시 (Reverse Proxy):</strong> <strong>서버 쪽에</strong> 위치합니다. 클라이언트가 우리 서버에 접속할 때, 그 요청을 대신 받아 내부 서버로 연결해주는 서버입니다. (예: 로드 밸런싱, SSL 암호화 처리)</li>
</ul>
</blockquote>