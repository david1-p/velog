<h2 id="분산-시스템의-데이터-정합성을-지키는-트랜잭셔널-아웃박스-패턴">분산 시스템의 데이터 정합성을 지키는 '트랜잭셔널 아웃박스 패턴'</h2>
<p>분산 시스템, 특히 마이크로서비스 아키텍처(MSA)에서 자주 발생하는 고질적인 문제와 그 해결책인 <strong>트랜잭셔널 아웃박스 패턴(Transactional Outbox Pattern)</strong>에 대해 알아보겠습니다.</p>
<h3 id="1-분산-시스템의-이중-쓰기-문제">1. 분산 시스템의 '이중 쓰기' 문제</h3>
<p>마이크로서비스 환경에서는 하나의 서비스가 자신의 데이터베이스를 변경하는 것(Write)과 동시에, 다른 서비스에게 &quot;나에게 변화가 생겼어!&quot;라고 알리기 위해 메시지 브로커(Kafka, RabbitMQ 등)에 이벤트를 발행(Write)하는 경우가 흔합니다.</p>
<p>예를 들어, <code>상품</code> 서비스가 신규 상품을 등록한 뒤, <code>검색</code> 서비스나 <code>알림</code> 서비스가 이 사실을 알 수 있도록 <code>ProductCreated</code> 이벤트를 발행하는 상황을 가정해 보겠습니다.</p>
<p>아마 가장 직관적인 코드는 다음과 같을 것입니다.</p>
<pre><code class="language-java">// 위험한 방식의 예시 코드
@Transactional
public void createProduct(ProductCreateRequest request) {
    // 1. DB에 상품 정보를 저장한다.
    Product product = new Product(request.getName(), request.getPrice());
    productRepository.save(product);

    // 2. 외부에 이벤트를 발행한다.
    eventPublisher.publish(new NewProductEvent(product.getId()));
}</code></pre>
<p>이 코드는 단순해 보이지만 심각한 문제를 내포하고 있습니다. 바로 <strong>이중 쓰기(Dual Writing)</strong> 문제입니다.</p>
<h3 id="2-왜-이-코드는-위험할까요">2. 왜 이 코드는 위험할까요?</h3>
<p>위험한 이유는 <strong>두 개의 서로 다른 시스템(데이터베이스, 메시지 브로커)에 대한 쓰기 작업을 하나의 원자적인 트랜잭션으로 묶을 수 없기 때문</strong>입니다.</p>
<p>데이터베이스의 트랜잭션은 <code>productRepository.save(product)</code> 호출 이후, <code>@Transactional</code> 어노테이션에 의해 <code>createProduct</code> 메소드가 성공적으로 종료될 때 <code>COMMIT</code>이 실행됩니다.</p>
<p>이 과정을 간단한 의사 코드로 풀어서 살펴보겠습니다.</p>
<pre><code class="language-java">public void problematicTransactionLogic() {
    try {
        // 1. DB 트랜잭션 시작
        database.transaction.begin();

        // 2. 비즈니스 로직 수행 (DB 쓰기)
        Product product = new Product(&quot;신규 상품&quot;);
        productRepository.save(product);

        // 3. 외부 시스템에 이벤트 발행
        eventPublisher.publish(new NewProductEvent(product.getId()));

        // 4. DB 트랜잭션 커밋
        database.transaction.commit();

    } catch (Exception e) {
        // 5. 문제 발생 시 DB 롤백
        database.transaction.rollback();
    }
}</code></pre>
<p>여기서 발생할 수 있는 두 가지 최악의 시나리오가 있습니다.</p>
<ol>
<li><p><strong>시나리오 A: DB 커밋 성공, 이벤트 발행 실패</strong></p>
<ul>
<li><code>productRepository.save(product)</code>는 성공했습니다.</li>
<li><code>eventPublisher.publish(...)</code>가 네트워크 문제나 브로커 장애로 <strong>실패</strong>했습니다.</li>
<li>메소드에서 예외가 발생하여 <code>database.transaction.rollback()</code>이 호출됩니다.</li>
<li><strong>결과:</strong> 실제로는 상품이 성공적으로 저장될 <em>뻔</em> 했지만, 이벤트 발행 실패 때문에 상품 등록 자체가 롤백됩니다. (혹은 예외 처리를 <code>publish</code>에서 따로 한다면, 상품은 DB에 있지만 이벤트는 발행되지 않아 아무도 모르는 유령 데이터가 됩니다.)</li>
</ul>
</li>
<li><p><strong>시나리오 B: DB 커밋 실패, 이벤트 발행 성공</strong></p>
<ul>
<li><code>productRepository.save(product)</code>는 성공했습니다.</li>
<li><code>eventPublisher.publish(...)</code>도 <strong>성공</strong>했습니다.</li>
<li>하지만 <code>database.transaction.commit()</code> 시점에 DB 장애, 락(Lock) 문제 등으로 <strong>커밋이 실패</strong>하고 롤백됩니다.</li>
<li><strong>결과:</strong> DB에는 상품 데이터가 없는데, &quot;신규 상품이 등록되었다!&quot;라는 이벤트는 이미 외부 시스템에 전파되었습니다. 다른 서비스들은 존재하지 않는 상품을 참조하려다 장애를 일으킬 것입니다.</li>
</ul>
</li>
</ol>
<p>이처럼 두 작업 중 하나만 성공하는 상황은 <strong>서비스 전체의 데이터 정합성을 심각하게 훼손</strong>시킵니다.</p>
<h3 id="3-해결책-트랜잭셔널-아웃박스-패턴-transactional-outbox-pattern">3. 해결책: 트랜잭셔널 아웃박스 패턴 (Transactional Outbox Pattern)</h3>
<p>이 문제를 해결하는 것이 바로 <strong>트랜잭셔널 아웃박스 패턴</strong>입니다.</p>
<p>핵심 아이디어는 간단합니다.</p>
<blockquote>
<p>&quot;외부 시스템(메시지 브로커)에 직접 이벤트를 발행하지 말고, '발행할 이벤트' 자체를 내 데이터베이스에 저장하자!&quot;</p>
</blockquote>
<p>즉, 비즈니스 데이터(상품)를 저장하는 작업과, 발행할 이벤트(상품 생성 이벤트)를 저장하는 작업을 <strong>하나의 DB 트랜잭션</strong>으로 묶어 원자성을 보장하는 것입니다.</p>
<p>이를 위해 <code>OUTBOX</code>라는 별도의 테이블을 만듭니다.</p>
<pre><code class="language-SQL">예시: 이벤트 저장을 위한 Outbox 테이블
CREATE TABLE product_outbox (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    event_type VARCHAR(255) NOT NULL,
    payload TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    processed BOOLEAN DEFAULT FALSE -- (추가) 처리 여부를 추적할 수 있습니다.
);</code></pre>
<h3 id="4-아웃박스-패턴의-구현">4. 아웃박스 패턴의 구현</h3>
<p>이제 아웃박스 패턴을 적용하여 코드를 수정해 보겠습니다.</p>
<pre><code class="language-java">// 트랜잭셔널 아웃박스 패턴이 적용된 코드
@Transactional
public void createProduct(ProductCreateRequest request) {
    // 1. 비즈니스 데이터(상품) 저장
    Product product = new Product(request.getName(), request.getPrice());
    productRepository.save(product);

    // 2. 발행할 이벤트를 Outbox 테이블에 저장
    // (아직 진짜 발행(publish)한 것이 아님!)
    ProductEvent event = new ProductEvent(product.getId(), &quot;PRODUCT_CREATED&quot;, request);
    productOutboxRepository.save(event);

    // 3. 트랜잭션 커밋
    // 이제 productRepository.save(product)와
    // productOutboxRepository.save(event)는
    // 같은 DB 트랜잭션으로 묶여 원자성을 보장받습니다.
}</code></pre>
<p>이제 어떻게 될까요?</p>
<ul>
<li><code>product</code> 저장이 성공하고 <code>event</code> 저장도 성공하면, 트랜잭션이 <strong>커밋</strong>됩니다. (성공)</li>
<li><code>product</code> 저장은 성공했지만 <code>event</code> 저장이 실패하면, 트랜잭션이 <strong>롤백</strong>됩니다. (데이터 정합성 유지)</li>
<li><code>product</code> 저장, <code>event</code> 저장이 모두 성공했지만 커밋이 실패하면, 트랜잭션이 <strong>롤백</strong>됩니다. (데이터 정합성 유지)</li>
</ul>
<p>이로써 DB와 이벤트 발행 간의 원자성(Atomicity) 문제는 해결됩니다.
다만 이후 이벤트 발행 과정에서 중복 전송이 일어날 수 있으므로, 소비자 측에서 멱등성을 보장해야 완전한 정합성이 유지됩니다.</p>
<h3 id="5-outbox의-이벤트를-진짜-발행하기-polling-vs-cdc">5. Outbox의 이벤트를 '진짜' 발행하기 (Polling vs. CDC)</h3>
<p>&quot;좋아, 이제 이벤트가 DB에 저장된 건 알겠어. 그럼 이걸 언제, 누가 메시지 브로커로 보내주지?&quot;</p>
<p>여기서부터는 <strong>별도의 비동기 프로세스</strong>가 필요합니다. 이 프로세스는 <code>OUTBOX</code> 테이블을 감시하다가, 새로 추가된 이벤트를 실제 메시지 브로커로 전달하는 '우체부' 역할을 합니다.</p>
<p>이 '우체부'를 구현하는 방식은 크게 두 가지입니다.</p>
<h4 id="a-폴링-polling-방식">A. 폴링 (Polling) 방식</h4>
<p>가장 구현하기 쉬운 방식입니다.</p>
<ul>
<li><strong>작동 방식:</strong> 별도의 스케줄러(예: Spring의 <code>@Scheduled</code>)가 주기적으로(예: 매 1초마다) <code>OUTBOX</code> 테이블을 <code>SELECT</code> 합니다.</li>
<li>아직 처리되지 않은(<code>processed = false</code>) 이벤트를 가져와 메시지 브로커로 발행합니다.</li>
<li>발행에 성공하면 해당 이벤트를 <code>OUTBOX</code> 테이블에서 삭제하거나, <code>processed = true</code>로 업데이트합니다.</li>
<li><strong>단점:</strong><ul>
<li>폴링 주기가 너무 짧거나 Outbox 데이터가 많아질 경우 DB 부하가 증가할 수 있습니다.
하지만 일반적인 트래픽 규모에서는 실질적인 부담이 크지 않으며, 구현이 간단하다는 장점이 있습니다.</li>
<li>이벤트 발생 시점과 실제 발행 시점 사이에 지연(Latency)이 발생합니다. (스케줄링 주기만큼)</li>
</ul>
</li>
</ul>
<h4 id="b-cdc-change-data-capture-방식">B. CDC (Change Data Capture) 방식</h4>
<p>더욱 효율적이고 세련된 방식입니다.</p>
<ul>
<li><strong>작동 방식:</strong> 애플리케이션이 DB를 직접 폴링하는 것이 아니라, <strong>데이터베이스의 트랜잭션 로그(Transaction Log)</strong>를 모니터링합니다.</li>
<li>MySQL의 <code>Binlog</code>, PostgreSQL의 <code>WAL</code> 등이 트랜잭션 로그입니다.</li>
<li><strong>Debezium</strong> 같은 CDC 도구가 이 로그를 읽다가, <code>OUTBOX</code> 테이블에 <code>INSERT</code>가 발생한 것을 '캡처'합니다.</li>
<li>캡처된 이벤트를 즉시 Kafka와 같은 메시지 브로커로 전달(Relay)합니다.</li>
<li><strong>장점:</strong><ul>
<li>DB에 폴링 부하를 전혀 주지 않습니다.</li>
<li>이벤트가 커밋되는 즉시 로그에 기록되므로, 거의 실시간(Near real-time)으로 이벤트를 발행할 수 있습니다.</li>
</ul>
</li>
<li><strong>단점:</strong> Debezium, Kafka Connect 등 별도의 CDC 파이프라인을 구축해야 하므로 초기 설정이 복잡합니다.</li>
<li>Debezium은 Kafka Connect 기반으로 동작하며, 데이터베이스의 트랜잭션 로그를 읽어 Kafka 토픽으로 바로 내보내는 Connector 역할을 합니다.
이후 애플리케이션은 Kafka 토픽을 구독하여 이벤트를 처리하면 됩니다.</li>
</ul>
<h3 id="6-아웃박스-패턴의-보장과-고려사항">6. 아웃박스 패턴의 보장과 고려사항</h3>
<ul>
<li><p><strong>적어도 한 번 전송 (At-least-once Delivery)</strong>
  아웃박스 패턴은 이벤트 발행 프로세스(우체부)가 브로커에게 이벤트를 '성공할 때까지' 재시도할 수 있게 해줍니다. (예: 발행 후 <code>OUTBOX</code>에서 삭제하기 직전에 '우체부' 프로세스가 죽는 경우, 재시작 시 동일 이벤트를 다시 발행함)
  따라서 이 패턴은 <strong>&quot;적어도 한 번&quot;</strong> 이벤트가 발행되는 것을 보장합니다.</p>
</li>
<li><p><strong>소비자의 멱등성 (Idempotency)</strong>
  '적어도 한 번'이 보장된다는 것은, 네트워크 문제 등으로 인해 <strong>'중복 발행'</strong>이 발생할 수 있다는 의미이기도 합니다. 따라서 이 이벤트를 수신하는 <strong>소비자(Consumer)는 반드시 멱등성(Idempotent)</strong>을 갖도록 설계해야 합니다. 즉, 같은 이벤트를 여러 번 수신하더라도 단 한 번만 처리된 것과 동일한 결과를 내도록 만들어야 합니다.</p>
</li>
</ul>
<h3 id="7-요약">7. 요약</h3>
<ol>
<li>단일 트랜잭션에서 DB 쓰기와 외부 메시지 발행을 함께 처리하면 '이중 쓰기' 문제로 데이터 정합성이 깨진다.</li>
<li><strong>트랜잭셔널 아웃박스 패턴</strong>은 외부 메시지를 직접 발행하는 대신, '발행할 이벤트'를 DB 내 <code>OUTBOX</code> 테이블에 저장한다.</li>
<li>비즈니스 로직과 이벤트 저장은 <strong>동일한 DB 트랜잭션</strong>으로 묶여 원자성을 보장받는다.</li>
<li><strong>별도의 릴레이 프로세스</strong>(Polling 또는 CDC)가 <code>OUTBOX</code> 테이블을 감시하여 실제 메시지 브로커로 이벤트를 전송한다.</li>
<li>이 패턴은 “DB 변경 → 이벤트 발행”이 반드시 일관되게 수행되도록 보장합니다.
따라서 이벤트 기반 아키텍처에서 데이터 정합성을 확보하는 핵심 패턴으로 널리 활용됩니다.</li>
</ol>