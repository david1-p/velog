<h1 id="자료구조-해시-충돌hash-collision이란-무엇이며-어떻게-해결할까">[자료구조] 해시 충돌(Hash Collision)이란 무엇이며, 어떻게 해결할까?</h1>
<p>백엔드 개발에서 성능은 매우 중요하며, 데이터를 빠르게 조회하기 위해 해시(Hash) 기반의 자료 구조(해시 테이블, 해시맵 등)를 빈번하게 사용합니다. 해시 자료 구조의 핵심과 성능 저하의 주범인 '해시 충돌'에 대해 알아보겠습니다.</p>
<hr />
<h2 id="해시hash-자료-구조란">해시(Hash) 자료 구조란?</h2>
<p>해시 자료 구조는 <strong>키-값 쌍(Key-Value pair)</strong>으로 이루어진 데이터 구조입니다.</p>
<p>가장 큰 특징은 키(Key)를 이용해 값(Value)을 평균 <strong>$O(1)$</strong>의 매우 빠른 시간 복잡도로 찾을 수 있다는 것입니다.</p>
<p>이것이 가능한 이유는 내부적으로 키를 <strong>해시 함수(Hash Function)</strong>에 통과시켜 반환된 '해시 값'을 배열의 인덱스로 사용하여 값을 관리하기 때문입니다.</p>
<h2 id="해시-충돌-hash-collision-이란">해시 충돌 (Hash Collision) 이란?</h2>
<p>해시 자료 구조는 키를 해시 함수에 넣어서 나오는 결과를 기반으로 값을 관리합니다. 하지만 해시 함수는 종종 <strong>서로 다른 키를 사용해도 같은 해시 값을 반환</strong>하는 경우가 존재합니다.</p>
<p>이처럼 서로 다른 키가 같은 인덱스(버킷)로 매핑되는 상황을 <strong>해시 충돌(Hash Collision)</strong>이라고 합니다.</p>
<p>해시 충돌이 발생하면 $O(1)$의 시간 복잡도를 보장할 수 없게 되며, 충돌이 많아질수록 성능은 $O(n)$에 가까워질 수 있습니다. 따라서 이 충돌을 효율적으로 관리하고 완화하는 것이 핵심입니다.</p>
<hr />
<h2 id="해시-충돌-완화-전략">해시 충돌 완화 전략</h2>
<p>해시 충돌을 완화하기 위한 접근 방법으로 크게 두 가지가 대표적입니다.</p>
<ol>
<li><strong>분리 연결법 (Separate Chaining)</strong></li>
<li><strong>개방 주소법 (Open Addressing)</strong></li>
</ol>
<h3 id="1-분리-연결법-separate-chaining">1. 분리 연결법 (Separate Chaining)</h3>
<p><strong>분리 연결법</strong>은 이름 그대로 충돌이 발생한 데이터를 기존 데이터에 '연결'시키는 방식입니다.</p>
<p>즉, 각 버킷을 단순한 값이 아닌 <strong>연결 리스트(Linked List)</strong>나 <strong>트리(Tree)</strong> 형태로 관리하여, 충돌이 발생하더라도 해당 버킷에 데이터를 계속해서 추가할 수 있도록 합니다.</p>
<ul>
<li><strong>장점</strong>: 구현이 비교적 간단하고, 데이터가 많아져도(적재율이 높아져도) 개방 주소법에 비해 성능 저하가 완만한 편입니다.</li>
<li><strong>단점</strong>: 연결 리스트나 트리를 위한 추가적인 메모리 공간이 필요합니다.</li>
</ul>
<h4 id="추가-분리-연결법의-성능-최적화-list-to-tree">(추가) 분리 연결법의 성능 최적화 (List to Tree)</h4>
<p>하나의 버킷에 데이터가 계속 쌓여 연결 리스트가 길어지면, 해당 버킷을 탐색하는 시간은 $O(n)$이 되어 성능이 저하됩니다.</p>
<p>많은 현대 언어의 해시맵 구현체(예: <strong>Java의 <code>HashMap</code></strong>)는 이 문제를 해결하기 위해, 특정 버킷의 연결 리스트 길이가 일정 임계값(예: 8개)을 초과하면, 해당 버킷의 자료 구조를 연결 리스트에서 <strong>레드-블랙 트리(Red-Black Tree)</strong>와 같은 균형 잡힌 이진 탐색 트리로 변환합니다.</p>
<ul>
<li><strong>연결 리스트</strong>: 탐색 시간 $O(n)$</li>
<li><strong>트리</strong>: 탐색 시간 $O(\log n)$</li>
</ul>
<p>이를 통해 최악의 경우에도 탐색 성능을 $O(\log n)$으로 보장할 수 있습니다.</p>
<h3 id="2-개방-주소법-open-addressing">2. 개방 주소법 (Open Addressing)</h3>
<p><strong>개방 주소법</strong>은 충돌이 발생했을 때, 해당 버킷이 이미 사용 중이라면 <strong>다른 비어있는 해시 버킷</strong>을 찾아 데이터를 삽입하는 방식입니다.</p>
<ul>
<li><strong>장점</strong>: 추가적인 메모리 공간이 필요 없으며, 데이터가 적을 때는 분리 연결법보다 빠를 수 있습니다. (캐시 효율성)</li>
<li><strong>단점</strong>: 데이터가 많아질수록(적재율이 높아질수록) 빈 버킷을 찾는 과정이 길어져 성능이 저하될 수 있으며, 데이터 삭제가 까다롭습니다.</li>
</ul>
<hr />
<h2 id="개방-주소법의-다른-버킷-찾는-방법-probing">개방 주소법의 '다른 버킷' 찾는 방법 (Probing)</h2>
<p>개방 주소법에서 빈 버킷을 찾기 위한 탐사(Probing) 방법에는 여러 가지가 존재합니다.</p>
<h3 id="1-선형-탐사법-linear-probing">1. 선형 탐사법 (Linear Probing)</h3>
<p>임의의 고정된 크기(예: 1)만큼 <strong>한 칸씩</strong> 순차적으로 이동하며 빈 버킷을 찾는 가장 간단한 방법입니다.</p>
<ul>
<li><strong>단점</strong>: 특정 버킷 주변이 모두 채워져 있는 <strong>1차 군집 현상(Primary Clustering)</strong>이 발생하기 쉽고, 이 경우 해시 성능이 크게 저하될 수 있습니다.</li>
</ul>
<h3 id="2-제곱-탐사법-quadratic-probing">2. 제곱 탐사법 (Quadratic Probing)</h3>
<p>선형 탐사법처럼 한 칸씩 찾는 것이 아닌, $1^2, 2^2, 3^2, ...$ 만큼의 보폭으로 <strong>제곱으로 늘려가며</strong> 빈 버킷을 찾습니다.</p>
<ul>
<li><strong>장점</strong>: 보폭이 점점 늘어나기 때문에 1차 군집 현상을 완화하여 특정 영역을 빠르게 벗어날 수 있습니다.</li>
<li><strong>단점</strong>: 여러 키가 해시 함수로 같은 값을 갖게 될 경우, 모두 같은 순서로 탐사하게 되어 비효율적인 상황(<strong>2차 군집 현상, Secondary Clustering</strong>)이 발생할 수 있습니다.</li>
</ul>
<h3 id="3-이중-해싱-double-hashing">3. 이중 해싱 (Double Hashing)</h3>
<p>해시 충돌이 발생하는 경우, <strong>두 번째 보조 해시 함수(Auxiliary Hash Function)</strong>를 사용하는 방법입니다.</p>
<p>첫 번째 해시 값으로는 초기 위치를 정하고, 충돌 시 두 번째 해시 함수의 결과값만큼 일정하게 이동하며 빈 버킷을 찾습니다.</p>
<ul>
<li><strong>장점</strong>: 키마다 이동하는 보폭이 달라지므로, 군집 현상(Clustering)이 발생할 가능성이 가장 작습니다.</li>
<li><strong>단점</strong>: 추가적인 보조 해시 함수 연산이 필요하므로 다른 방식에 비해 연산량이 많습니다.</li>
</ul>
<hr />
<h2 id="추가-해시-성능-유지를-위한-핵심-적재율과-리해싱">(추가) 해시 성능 유지를 위한 핵심: 적재율과 리해싱</h2>
<p>해시 충돌은 피할 수 없지만, 충돌이 '너무 자주' 일어나지 않도록 관리하는 것이 중요합니다. 이때 사용되는 개념이 <strong>적재율(Load Factor)</strong>입니다.</p>
<ul>
<li><strong>적재율 (Load Factor)</strong>: 해시 테이블의 전체 버킷 수 대비 현재 얼마나 많은 데이터가 저장되어 있는지를 나타내는 비율입니다.<ul>
<li><code>적재율 = (저장된 데이터 개수) / (전체 버킷 수)</code></li>
</ul>
</li>
</ul>
<p>적재율이 너무 높아지면(예: 0.75 이상) 빈 공간이 줄어들어 해시 충돌이 급격하게 증가하고 성능이 저하됩니다.</p>
<h3 id="리해싱-rehashing">리해싱 (Rehashing)</h3>
<p>이 문제를 해결하기 위해 해시 테이블은 적재율이 특정 임계값(예: Java <code>HashMap</code>의 기본값 0.75)을 초과하면 <strong>리해싱(Rehashing)</strong>을 수행합니다.</p>
<p><strong>리해싱</strong>이란, 기존보다 더 큰 크기(보통 2배)의 새로운 버킷 배열을 생성한 뒤, 기존의 모든 데이터를 새로운 해시 함수(또는 변경된 인덱스 계산)에 따라 새 배열에 다시 삽입하는 과정을 말합니다.</p>
<p>리해싱은 비용이 많이 드는 작업이지만, 적재율을 낮춰 다시 $O(1)$의 평균 시간 복잡도를 유지할 수 있도록 해주는 필수적인 작업입니다.</p>